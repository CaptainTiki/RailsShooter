extends Weapon
class_name BeamWeapon

enum BeamState {ON, OFF}

@export var projo_scene : PackedScene = preload("res://gameplay/projectiles/bullets/basic_bullet_proj.tscn")
@onready var fire_rate_timer: Timer = $Fire_Rate_Timer
@onready var beam_mesh: MeshInstance3D = $Rotation_Handle/Beam_Mesh

var dmg_pr_sec : float = 1 # this is applied * delta

var beam_state : BeamState = BeamState.OFF
var range: float = 50

func _ready() -> void:
	set_beam_mesh(false)
	weapon_belt = Belt.SECONDARY

func _process(delta: float) -> void:
	process_beam(delta)
	
func process_beam(delta: float) -> void:
	if beam_state == BeamState.OFF:
		return
	
	var origin := global_position  # or a $Muzzle.global_position if you have it
	var target : Targetable = hub.playership.current_target  # best: use centralized aim point

	if target:
		update_beam_visual(origin, target.global_position)
	else:
		update_beam_visual(origin, hub.playership.aim_dir * range)
	
	if fire_rate_timer.is_stopped():
		if try_consume_ammo():
			fire_rate_timer.start() #time is set in inspector
	else:
		if target and target.has_method("take_damage"):
			target.take_damage(dmg_pr_sec * delta)

func fire_pressed() -> void:
	if beam_state == BeamState.ON:
		return
	beam_state = BeamState.ON
	fire_rate_timer.stop()
	set_beam_mesh(true)

func fire_released() -> void:
	beam_state = BeamState.OFF
	fire_rate_timer.stop()
	set_beam_mesh(false)

func set_beam_mesh(active : bool) -> void:
	beam_mesh.visible = active
	#TODO: set endpoints to the weapon - and tgt - stretch the length, etc

func update_beam_visual(origin: Vector3, target: Vector3) -> void:
	var dir := target - origin
	var dist := dir.length()
	if dist < 0.001:
		beam_mesh.visible = false
		return

	beam_mesh.visible = true
	# Put beam in the middle between origin and target
	beam_mesh.global_position = origin + dir * 0.5
	# Rotate so its +Y points toward target
	beam_mesh.global_transform.basis = Basis.looking_at(dir.normalized(), Vector3.UP)
	# Scale height to distance (since cylinder height is along Y)
	var s := beam_mesh.scale
	s.y = dist
	beam_mesh.scale = s


func try_consume_ammo() -> bool:
	if not hub.has_ammo(ammo_type, ammo_cost_per_shot): #not enough ammo to shoot
		return false
	hub.consume_ammo(ammo_type, ammo_cost_per_shot)
	return true
