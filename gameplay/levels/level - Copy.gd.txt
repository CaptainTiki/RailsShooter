extends Node3D
class_name Level


signal level_ready

@onready var enemy_parent: Node3D = $EnemyParent
@onready var room_manager: Node3D = $RoomManager

var player_scene : PackedScene = preload("res://gameplay/player/player_root.tscn")
var arena_debug_scene : PackedScene = preload("res://gameplay/levels/rooms/room_arena_debug.tscn")

var player_root: PlayerRoot
var elapsed_run_time : float = 0
var completed_rooms : int = 0
var target_room_num : int = 4

var pending_rail_dock: RailDockTrigger = null

func _ready() -> void:
	GameManager.set_current_level(self)
	ready_first_room()
	level_ready.emit()
	GameManager.set_gamestate(Globals.GameState.IN_RUN)
	player_root.docking_controller.docking_complete.connect(_on_rail_docking_complete)

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
	elapsed_run_time += delta
	
	if Input.is_action_just_pressed("escape"):
		#TODO: show pause screen
		return_to_base(false) #assume this is from the pause menu and we just quit out
	if Input.is_action_just_pressed("debug_action_one"):
		GameManager.current_run.aetherium_ore += 1
		
	if Input.is_action_just_pressed("debug_win_run"):
		return_to_base(true)
	if Input.is_action_just_pressed("debug_action_two"):
		room_manager.spawn_debug_room_after_current(arena_debug_scene)
	pass

func ready_first_room() -> void:
	_spawn_player()
	room_manager.deploy_first_room() #deploy the moon pool room
	_parent_player_to_path() #parent player to the path in moon pool room
	player_root.docking_controller.docking_position = room_manager.get_room_path_start(room_manager.current_room)
	player_root.global_position = room_manager.get_room_path_start(room_manager.current_room)

func _spawn_player() -> void:
	var player : PlayerRoot = player_scene.instantiate() as PlayerRoot #player needs to be first , so targets can register as targetable
	player.parent_level = self
	player_root = player

func on_raildock_trigger(_ship_root: ShipRoot, trigger: RailDockTrigger) -> void:
	# Decide based on current move mode:
	match player_root.move_mode:
		PlayerRoot.MoveMode.ON_RAIL:
			_exit_rail_via_trigger(trigger)
		PlayerRoot.MoveMode.FREE_FLIGHT:
			_enter_rail_via_trigger(trigger)
		PlayerRoot.MoveMode.DOCKING, PlayerRoot.MoveMode.MOVE_TO_PATH:
			# Already transitioning - ignore extra hits
			return
func _enter_rail_via_trigger(trigger: RailDockTrigger) -> void:
	# Remember which trigger started this dock
	pending_rail_dock = trigger

	# Pick a docking target near the rail. For now, use the start of that room's path.
	var dock_pos : Vector3 = room_manager.get_room_path_start(trigger.parent_room)

	player_root.docking_controller.docking_position = dock_pos
	player_root.set_move_mode(PlayerRoot.MoveMode.DOCKING)

func _exit_rail_via_trigger(_trigger: RailDockTrigger) -> void:
	# Preserve world transform before we yank it out of the path
	var old_transform := player_root.global_transform
	var parent := player_root.get_parent()

	# Switch mode first so RailController stops touching the path
	player_root.set_move_mode(PlayerRoot.MoveMode.FREE_FLIGHT)

	# Reparent from Path (or whatever) back under the Level
	if parent:
		parent.remove_child(player_root)
	add_child(player_root)

	player_root.global_transform = old_transform
	# current_speed carries over; freeflight will keep you moving forward

func _on_rail_docking_complete() -> void:
	if pending_rail_dock == null:
		return

	# Preserve world transform where docking finished
	var old_transform := player_root.global_transform

	var dock_trigger := pending_rail_dock
	pending_rail_dock = null

	# Attach to that room's rail path
	var rail_room: Room = dock_trigger.parent_room
	var path: Path3D = rail_room.rail_path  # assuming your Room exposes this

	if player_root.get_parent():
		player_root.get_parent().remove_child(player_root)
	path.add_child(player_root)

	player_root.global_transform = old_transform

	# Use the trigger's progress/direction settings
	player_root.progress = dock_trigger.target_progress
	# later you can add a direction field to RailController and set it here:
	# player_root.rail_controller.direction = dock_trigger.direction

	player_root.set_move_mode(PlayerRoot.MoveMode.ON_RAIL)


func _move_player_to_path() -> void:
	player_root.docking_controller.docking_position = room_manager.get_room_path_start(room_manager.current_room)
	player_root.set_move_mode(PlayerRoot.MoveMode.MOVE_TO_PATH)

func _parent_player_to_path() -> void:
	player_root.set_progress(0)
	room_manager.parent_to_path(player_root)
	player_root.set_move_mode(PlayerRoot.MoveMode.ON_RAIL)

func _parent_player_to_room() -> void:
	var ship_pos : Vector3 = player_root.ship_root.global_position
	player_root.un_parent()
	add_child(player_root) #no path, parent to the level directly
	player_root.ship_root.position = Vector3.ZERO
	player_root.global_position = ship_pos
	player_root.set_move_mode(PlayerRoot.MoveMode.FREE_FLIGHT)

#called by the player - who has exited a room (hit the end of the path, or triggered an exit node)
func _end_rail_room() -> void:
	completed_rooms += 1
	if completed_rooms >= target_room_num:
		return_to_base(true)

func _end_arena_room() -> void:
	completed_rooms += 1
	if completed_rooms >= target_room_num:
		return_to_base(true)

func return_to_base(bring_cargo : bool) -> void:
	GameManager.set_gamestate(Globals.GameState.LOADING) #get our loading overlay
	GameManager.current_run.success = bring_cargo #tell the run we were success or not
	GameManager.current_run.time_elapsed = elapsed_run_time #mark our time in the level
	GameManager.end_run(bring_cargo) #this copies the data from current to persistant
	var new_menu : BaseMenu = preload("res://base/ui/base_menu.tscn").instantiate() #load our menus
	get_tree().root.add_child.call_deferred(new_menu) #now add the menus to the tree
	queue_free() #close out the level
