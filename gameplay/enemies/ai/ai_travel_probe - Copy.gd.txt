extends Node3D
class_name AITravelProbe

@onready var context: AIContext = $"../AIContext"

@onready var avoid_rays: Node3D = $Probe_Handle/AvoidRays
@onready var ray_upleft: RayCast3D = $Probe_Handle/AvoidRays/RayCast_UpLeft
@onready var ray_upright: RayCast3D = $Probe_Handle/AvoidRays/RayCast_UpRight
@onready var ray_downleft: RayCast3D = $Probe_Handle/AvoidRays/RayCast_DownLeft
@onready var ray_downright: RayCast3D = $Probe_Handle/AvoidRays/RayCast_DownRight

@onready var centering_rays: Node3D = $Probe_Handle/CenteringRays
@onready var ray_up: RayCast3D = $Probe_Handle/CenteringRays/RayCast_Up
@onready var ray_down: RayCast3D = $Probe_Handle/CenteringRays/RayCast_Down
@onready var ray_right: RayCast3D = $Probe_Handle/CenteringRays/RayCast_Right
@onready var ray_left: RayCast3D = $Probe_Handle/CenteringRays/RayCast_Left

var avoid_dir : Vector3 = Vector3.ZERO
var avoid_weight : float = 0
var center_dir : Vector3 = Vector3.ZERO
var center_weight : float = 0
var avoid_amount : float = 1.2
var centering_ammount : float = 0.8
var colliding : bool = false
var offcenter : bool = false

var update_timer_max : float = 0.25
var update_timer : float = 0.25

func _ready() -> void:
	#randomize so not everybody updates a the SAME TIME - causing hitching
	update_timer_max = randf_range(.2, .3)
	update_timer = update_timer_max
	pass

func _physics_process(delta: float) -> void:
	update_timer -= delta
	if update_timer > 0:
		return
	
	update_detector_orientation()
	
	update_timer = update_timer_max
	calc_avoid_dir()
	calc_center_dir()

func update_detector_orientation() -> void:
	#rotate the detector rays to face direction of travel:
	if context.steering_dir.length() > 0:
		avoid_rays.look_at(global_position + context.steering_dir)

func calc_avoid_dir() -> void:
	avoid_dir = Vector3.ZERO
	avoid_weight = 0
	colliding = false
	
	var ul : Vector3 = check_avoid_raycast(ray_upleft)
	var ur : Vector3  = check_avoid_raycast(ray_upright)
	var dl : Vector3  = check_avoid_raycast(ray_downleft)
	var dr : Vector3  = check_avoid_raycast(ray_downright)

	avoid_dir = (ul+ur+dl+dr).normalized()
	avoid_weight = avoid_weight * avoid_amount

func calc_center_dir() -> void:
	center_dir = Vector3.ZERO
	center_weight = 0
	offcenter = false
	var u : Vector3 = check_center_raycast(ray_up)
	var d : Vector3  = check_center_raycast(ray_down)
	var l : Vector3  = check_center_raycast(ray_left)
	var r : Vector3  = check_center_raycast(ray_right)
	
	center_dir = (u+d+l+r).normalized()
	center_weight = center_weight * centering_ammount
	
##Returns Vector3.ZERO if no collison.
func check_avoid_raycast(ray: RayCast3D) -> Vector3:
	if not ray.is_colliding():
		return Vector3.ZERO #if we dont collide - return nothing
	
	#add the length of ray, minus the length of collision (lower is further away)
	avoid_weight += 10 - (ray.get_collision_point() - global_position).length()
	colliding = true
	
	return ray.get_collision_normal()

##Returns Vector3.ZERO if no collison.
func check_center_raycast(ray: RayCast3D) -> Vector3:
	if not ray.is_colliding():
		return Vector3.ZERO #if we dont collide - return nothing
	
	colliding = true
	center_weight += 10 - (ray.get_collision_point() - global_position).length()
	return ray.get_collision_normal()

func get_avoid_dir() -> Vector3:
	return avoid_dir
	
func get_avoid_weight() -> float:
	return avoid_weight
	
func get_centering_dir() -> Vector3:
	return center_dir
	
func get_centering_weight() -> float:
	return center_weight
